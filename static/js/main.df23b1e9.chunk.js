(this["webpackJsonpgalaxy-genetator"]=this["webpackJsonpgalaxy-genetator"]||[]).push([[0],{18:function(n,e,t){},19:function(n,e,t){},22:function(n,e,t){"use strict";t.r(e);var o=t(8),i=t.n(o),a=t(11),r=t.n(a),s=(t(18),t(19),t(4)),d=t(13),l=t(12),h=t(6),c=function(){var n=new s.k,e=new l.a,t={width:window.innerWidth,height:window.innerHeight},o={x:0,y:0};window.addEventListener("mousemove",(function(n){o.x=n.clientX/t.width-.5,o.y=n.clientY/t.height-.5}));var i={count:3e5,size:.01,radius:7,branches:5,spin:0,randomnessPower:3,insideColor:"#ff6030",outsideColor:"#1b3984"},a=null,r=null,c=null,u=function(){null!==c&&(a.dispose(),r.dispose(),n.remove(c)),a=new s.c;for(var e=new Float32Array(3*i.count),t=new Float32Array(3*i.count),o=new Float32Array(1*i.count),d=new Float32Array(3*i.count),l=new s.e(i.insideColor),h=new s.e(i.outsideColor),u=0;u<i.count;u++){var g=3*u,m=i.radius*Math.random(),w=u%i.branches/i.branches*2*Math.PI;e[g]=Math.cos(w)*m,e[g+1]=0,e[g+2]=Math.sin(w)*m;var p=Math.pow(Math.random(),i.randomnessPower)*(Math.random()<.5?1:-1),P=Math.pow(Math.random(),i.randomnessPower)*(Math.random()<.5?1:-1),f=Math.pow(Math.random(),i.randomnessPower)*(Math.random()<.5?1:-1);d[g+0]=p,d[g+1]=P,d[g+2]=f;var C=l.clone();C.lerp(h,m/i.radius),t[g]=C.r,t[g+1]=C.g,t[g+2]=C.b,o[u]=Math.random()}a.setAttribute("position",new s.b(e,3)),a.setAttribute("color",new s.b(t,3)),a.setAttribute("aScale",new s.b(o,1)),a.setAttribute("aRandomNess",new s.b(d,3)),r=new s.l({depthWrite:!1,blending:s.a,vertexColors:!0,vertexShader:"\n\nuniform float uSize;\nuniform float uTime;\n\nattribute float aScale;\nattribute vec3 aRandomNess;\n\nvarying vec3 vColor;\n\nvoid main(){\n\n    /* postions */\n\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\n    /* Spin */\n    float angle = atan(modelPosition.x, modelPosition.z);\n    float distanceToCenter = length(modelPosition.xz);\n    float angleOffset = ( 1.0 / distanceToCenter ) * uTime * 0.2;\n    angle += angleOffset;\n    modelPosition.x = cos(angle) * distanceToCenter;\n    modelPosition.z = sin(angle) * distanceToCenter;\n\n    /* Randomness */\n    // or modelPosition.xyz += aRandomNess;\n    modelPosition.x += aRandomNess.x;\n    modelPosition.y += aRandomNess.y;\n    modelPosition.z += aRandomNess.z;\n\n\n    vec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectionPosition = projectionMatrix * viewPosition;\n    gl_Position = projectionPosition;\n\n    /* Size */\n    gl_PointSize = uSize * aScale;\n    \n    // we set sizeAttenuation on our own, since shaderMaterial doesn't support sizeAttenuation = true like pointMaterial\n    gl_PointSize *= ( 1.0 / - viewPosition.z);  \n\n\n\n    vColor = color;\n\n\n    \n\n}\n\n",fragmentShader:"\n\nvarying vec3 vColor;\n\nvoid main(){\n\n    /* Disc pattern */\n    // float strength = distance(gl_PointCoord, vec2(0.5));\n    // strength = step(0.5, strength);\n    // strength = 1.0 - strength;\n\n    /* Diffuse Point pattern*/\n    // float strength = distance(gl_PointCoord, vec2(0.5));\n    // strength *= 2.0 ;\n    // strength = 1.0 - strength;\n\n    /* Light Point pattern*/\n    float strength = distance(gl_PointCoord, vec2(0.5));\n    strength = 1.0 - strength;\n    strength = pow(strength, 10.0);\n\n\n    /* Final Color */\n    vec3 color = mix(vec3(0.0), vColor, strength);\n\n    // we cannot send uv as a varying because each vertex is a particle but we can use gl_PointCoord\n    gl_FragColor = vec4(color, 1.0);\n\n}\n\n",uniforms:{uTime:{value:0},uSize:{value:30*v.getPixelRatio()}}}),c=new s.i(a,r),n.add(c)};e.add(i,"count").min(100).max(1e6).step(100).onFinishChange(u),e.add(i,"size").min(.001).max(.1).step(.001).onFinishChange(u),e.add(i,"radius").min(1).max(20).step(.1).onFinishChange(u),e.add(i,"branches").min(2).max(20).step(1).onFinishChange(u),e.add(i,"randomnessPower").min(1).max(10).step(.001).onFinishChange(u),e.addColor(i,"insideColor").onFinishChange(u),e.addColor(i,"outsideColor").onFinishChange(u);var g=new s.h(70,t.width/t.height,.1,100);g.position.set(3,4,3),n.add(g),window.addEventListener("resize",(function(){t.width=window.innerWidth,t.height=window.innerHeight,g.aspect=t.width/t.height,g.updateProjectionMatrix(),v.setSize(t.width,t.height),v.setPixelRatio(Math.min(window.devicePixelRatio,2))}));var m=document.querySelector(".webgl"),w=new d.a(g,m);w.enableDamping=!0;var v=new s.q({canvas:m});v.setSize(t.width,t.height);var p=new s.d;return u(),function e(){var t=p.getElapsedTime();r.uniforms.uTime.value=t,w.update(),v.render(n,g),window.requestAnimationFrame(e)}(),Object(h.jsx)(h.Fragment,{})};var u=function(){return Object(h.jsx)("div",{className:"App",children:Object(h.jsx)(c,{})})},g=function(n){n&&n instanceof Function&&t.e(3).then(t.bind(null,23)).then((function(e){var t=e.getCLS,o=e.getFID,i=e.getFCP,a=e.getLCP,r=e.getTTFB;t(n),o(n),i(n),a(n),r(n)}))};r.a.render(Object(h.jsx)(i.a.StrictMode,{children:Object(h.jsx)(u,{})}),document.getElementById("root")),g()}},[[22,1,2]]]);
//# sourceMappingURL=main.df23b1e9.chunk.js.map